package com.ashfaq.unittesting.controller;


import com.fasterxml.jackson.databind.ObjectMapper;
import com.ashfaq.unittesting.model.MyUser;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;

@SpringBootTest
@AutoConfigureMockMvc
 class RegistrationControllerTest {

    public static final Logger log = LoggerFactory.getLogger(RegistrationControllerTest.class);
    @Autowired
    private MockMvc mockMvc;
    /*
    MockMvc is a class that allows us to perform HTTP calls to our Spring Boot application.
     */

    @Autowired
    private ObjectMapper objectMapper;
    /*
    ObjectMapper is a class that allows us to serialize and deserialize JSON objects.
    Objects -> Byte array or String JSON

    ***Alternative we can use Gson***

     */



    @Test
    public void testCreateUser_ValidUser()
    {

        var user = new MyUser();
        user.setUsername("sonu");
        user.setPassword("1234");
        user.setRole("USER");

        /*
        we have to user now we have to pass the user just like how we pass in  postman when requesting.
and also need to define how the response look like
         */
        try {
            mockMvc.perform(
                    MockMvcRequestBuilders.post("/register/user")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(objectMapper.writeValueAsString(user))// we have to pass the object as a json string or byte array i.e we have to serialize the object, we can use objectMapper to serialize the object


            ).andExpect(MockMvcResultMatchers.status().is(200))// we can perform like expect a single response method -> andExpect() or multiple responses method -> andExpectAll , or perform another action method ->  andDo().
                    .andExpect(MockMvcResultMatchers.jsonPath("$.username").value("sonu"))//in response, we are checking if the name is same as what we had provided
                    .andExpect(MockMvcResultMatchers.jsonPath("$.role").value("USER"))
                    .andExpect(MockMvcResultMatchers.jsonPath("$.password").value(Matchers.not("1234")))// the password should not be 1234 as the password will be encrypted
                    .andExpect(MockMvcResultMatchers.jsonPath("$.id").exists());//the id should exist as its auto generated by JPA
            //we can test the function.
        } catch (Exception e) {
            throw new RuntimeException(e);
        }


    }

    @Test
    public void testCreateUser_InvalidUser()
    {

        var user = new MyUser();
        user.setUsername("sonu");
        /*
        we will not provide the password and role
         */
//        user.setPassword("1234");
//        user.setRole("USER");

        /*
        we have to user now we have to pass the user just like how we pass in  postman when requesting.
and also need to define how the response look like
         */
        try {
            mockMvc.perform(
                            MockMvcRequestBuilders.post("/register/user")
                                    .contentType(MediaType.APPLICATION_JSON)
                                    .content(objectMapper.writeValueAsString(user))// we have to pass the object as a json string or byte array i.e we have to serialize the object, we can use objectMapper to serialize the object


                    ).andExpect(MockMvcResultMatchers.status().isInternalServerError());// we can perform like expect a single response method -> andExpect() or multiple responses method -> andExpectAll , or perform another action method ->  andDo().
            //we can test the function.
        } catch (Exception e) {
            throw new RuntimeException(e);
        }


    }
    /*
    as we are not passing the role and password we are getting IllegalArgumentException: so we have created a exception handler to provide an internal server error response

    @ExceptionHandler
    public ResponseEntity<ErrorResponse> handleIllegalArgumentException(IllegalArgumentException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ServerErrorException("NPE " , e));
    }
     */


//    @Autowired
//    private MyUserRepository myUserRepository; commenting out to use in-mem db

    @AfterEach
    public void cleanUp()
    {

        log.info("AFTER EACH Clean up invoked");
//        myUserRepository.deleteAll();//this will delete all the users
        /*
        this can be a problem as it will delete all the users in the actual application database
    so we can configure the *** IN-MEMORY DB *** specially for testing
         */
    }
    /*

    i.e we have two test cases here so 1st test case will run then cleanup function will run , then 2nd test case will run then cleanup function will run.
     eg
   testFunc1();
    ae();
   testFunc2();
    ae();

     */


    /*
    Additional functions
     */
    @BeforeEach
    public void setUp()
    {

        log.info("Before EACH set up invoked");
    }
 /*
    i.e this function will run before each test case
    eg
    be();
    testFunc1();
    be();
    testFunc2();
    .....
     */


    @BeforeAll
    public static void beforeAll()
    {
        log.info("BEFORE ALL invoked");
    }
    /*
    i.e this function will run before all the test cases

    eg
    beforeAll(); // only once executed
    testFunc1();
    testFunc2();
    testFunc2();

     */


    @AfterAll
    public static void afterAll(){
        log.info("AFTER ALL invoked");
    }
 /*
    i.e this function will run after all the test cases

    eg
    testFunc1();
    testFunc2();
    testFunc2();
    AfterAll(); // only once executed

     */




}
